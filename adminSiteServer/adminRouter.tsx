// Misc non-SPA views
import { Request, Response, Router } from "express"
import * as express from "express"
import rateLimit from "express-rate-limit"
import filenamify from "filenamify"
import React from "react"
import { getConnection } from "typeorm"
import {
    expectInt,
    tryInt,
    renderToHtmlPage,
} from "../serverUtils/serverUtil.js"
import { logInWithCredentials, logOut } from "./authentication.js"
import { LoginPage } from "./LoginPage.js"
import { RegisterPage } from "./RegisterPage.js"
import * as db from "../db/db.js"
import { Dataset } from "../db/model/Dataset.js"
import { User } from "../db/model/User.js"
import { UserInvitation } from "../db/model/UserInvitation.js"
import { BAKED_BASE_URL, ENV } from "../settings/serverSettings.js"
import { ExplorerAdminServer } from "../explorerAdminServer/ExplorerAdminServer.js"
import { renderExplorerPage, renderPreview } from "../baker/siteRenderers.js"
import { JsonError } from "../clientUtils/owidTypes.js"
import { GitCmsServer } from "../gitCms/GitCmsServer.js"
import { GIT_CMS_DIR } from "../gitCms/GitCmsConstants.js"
import {
    parseIntOrUndefined,
    slugify,
    stringifyUnkownError,
} from "../clientUtils/Util.js"
import {
    DefaultNewExplorerSlug,
    EXPLORERS_PREVIEW_ROUTE,
    GetAllExplorersRoute,
} from "../explorer/ExplorerConstants.js"
import {
    ExplorerProgram,
    EXPLORER_FILE_SUFFIX,
} from "../explorer/ExplorerProgram.js"
import { existsSync } from "fs"

// Used for rate-limiting important endpoints (login, register) to prevent brute force attacks
const limiterMiddleware = (
    onFailRender: (req: Request, res: Response) => React.ReactElement
) =>
    rateLimit({
        windowMs: 60_000, // 1 minute
        max: 10, // max. 10 requests per minute
        handler: (req, res) =>
            res.status(429).send(renderToHtmlPage(onFailRender(req, res))),
    })

const adminRouter = Router()

// Parse incoming requests with JSON payloads http://expressjs.com/en/api.html
adminRouter.use(express.json({ limit: "50mb" }))

// None of these should be google indexed
adminRouter.use(async (req, res, next) => {
    res.set("X-Robots-Tag", "noindex")
    return next()
})

adminRouter.get("/", async (req, res) => {
    // Preview URLs generated by WP depend on the status of the post:
    // * PUBLISHED: owid.cloud/SLUG?preview=true --> run through WP singular.php
    //   and directly redirected to /admin/posts/preview/POST_ID
    // * DRAFT:
    //     - post: owid.cloud/?p=POST_ID&preview=true
    //     - page: owid.cloud/?page_id=PAGE_ID&preview=true
    //   --> "/" captured by NGINX and redirected here (/admin/)
    //
    // Ideally, the preview URL in WP would be pointing directly to
    // /admin/posts/preview/POST_ID (bypassing WP altogether, for published and
    // draft posts) but this is only partially possible for now, as the preview
    // URL of draft posts does not get rewritten by the preview_post_link filter
    // within Gutenberg.
    //
    // See:
    //  * https://github.com/WordPress/gutenberg/issues/13998
    //  * https://developer.wordpress.org/reference/hooks/preview_post_link/
    if (req.query.preview === "true" && (req.query.p || req.query.page_id)) {
        // HACK
        res.redirect(`/admin/posts/preview/${req.query.p || req.query.page_id}`)
    } else {
        res.redirect(`/admin/charts`)
    }
})

adminRouter.get("/login", async (req, res) => {
    res.send(renderToHtmlPage(<LoginPage next={req.query.next as string} />))
})
adminRouter.post(
    "/login",
    limiterMiddleware((req) => (
        <LoginPage
            errorMessage="Too many attempts, please try again in a minute."
            next={req.query.next as string}
        />
    )),
    async (req, res) => {
        try {
            const session = await logInWithCredentials(
                req.body.username,
                req.body.password
            )
            res.cookie("sessionid", session.id, {
                httpOnly: true,
                sameSite: "lax",
                secure: ENV === "production",
            })
            res.redirect((req.query.next as string) || "/admin")
        } catch (err) {
            res.status(400).send(
                renderToHtmlPage(
                    <LoginPage
                        next={req.query.next as string}
                        errorMessage={stringifyUnkownError(err)}
                    />
                )
            )
        }
    }
)

adminRouter.get("/logout", logOut)

adminRouter.get(
    "/register",
    limiterMiddleware((req) => (
        <RegisterPage
            errorMessage="Too many attempts, please try again in a minute."
            body={req.query}
        />
    )),
    async (req, res) => {
        if (res.locals.user) {
            res.redirect("/admin")
            return
        }

        let errorMessage: string | undefined
        let invite: UserInvitation | undefined
        try {
            // Delete all expired invites before continuing
            await UserInvitation.createQueryBuilder()
                .where("validTill < NOW()")
                .delete()
                .execute()

            invite = await UserInvitation.findOne({
                code: req.query.code as string,
            })
            if (!invite) throw new JsonError("Invite code invalid or expired")
        } catch (err) {
            errorMessage = stringifyUnkownError(err)
            res.status(tryInt((err as any).code, 500))
        } finally {
            res.send(
                renderToHtmlPage(
                    <RegisterPage
                        inviteEmail={invite && invite.email}
                        errorMessage={errorMessage}
                        body={req.query}
                    />
                )
            )
        }
    }
)

adminRouter.post(
    "/register",
    limiterMiddleware((req) => (
        <RegisterPage
            errorMessage="Too many attempts, please try again in a minute."
            body={req.query}
        />
    )),
    async (req, res) => {
        try {
            // Delete all expired invites before continuing
            await UserInvitation.createQueryBuilder()
                .where("validTill < NOW()")
                .delete()
                .execute()

            const invite = await UserInvitation.findOne({ code: req.body.code })
            if (!invite) {
                throw new JsonError("Invite code invalid or expired", 403)
            }

            if (req.body.password !== req.body.confirmPassword) {
                throw new JsonError("Passwords don't match!", 400)
            }

            await getConnection().transaction(async (manager) => {
                const user = new User()
                user.email = req.body.email
                user.fullName = req.body.fullName
                user.createdAt = new Date()
                user.updatedAt = new Date()
                user.lastLogin = new Date()
                await user.setPassword(req.body.password)
                await manager.getRepository(User).save(user)

                // Remove the invite now that it has been used successfully
                await manager.remove(invite)
            })

            await logInWithCredentials(req.body.email, req.body.password)
            res.redirect("/admin")
        } catch (err) {
            res.status(tryInt((err as any).code, 500))
            res.send(
                renderToHtmlPage(
                    <RegisterPage
                        errorMessage={stringifyUnkownError(err)}
                        body={req.body}
                    />
                )
            )
        }
    }
)

adminRouter.get("/datasets/:datasetId.csv", async (req, res) => {
    const datasetId = expectInt(req.params.datasetId)

    const datasetName = (
        await db.mysqlFirst(`SELECT name FROM datasets WHERE id=?`, [datasetId])
    ).name
    res.attachment(filenamify(datasetName) + ".csv")

    return Dataset.writeCSV(datasetId, res)
})

adminRouter.get("/datasets/:datasetId/downloadZip", async (req, res) => {
    const datasetId = expectInt(req.params.datasetId)

    res.attachment("additional-material.zip")

    const file = await db.mysqlFirst(
        `SELECT filename, file FROM dataset_files WHERE datasetId=?`,
        [datasetId]
    )
    res.send(file.file)
})

adminRouter.get("/posts/preview/:postId", async (req, res) => {
    const postId = expectInt(req.params.postId)

    res.send(await renderPreview(postId))
})

adminRouter.get("/errorTest.csv", async (req, res) => {
    // Add `table /admin/errorTest.csv?code=404` to test fetch download failures
    const code = parseIntOrUndefined(req.query.code as string) ?? 400

    res.status(code)

    return `Simulating code ${code}`
})

const explorerAdminServer = new ExplorerAdminServer(GIT_CMS_DIR)

adminRouter.get(`/${GetAllExplorersRoute}`, async (req, res) => {
    res.send(await explorerAdminServer.getAllExplorersCommand())
})

adminRouter.get(`/${EXPLORERS_PREVIEW_ROUTE}/:slug`, async (req, res) => {
    const slug = slugify(req.params.slug)
    const filename = slug + EXPLORER_FILE_SUFFIX
    if (slug === DefaultNewExplorerSlug)
        return res.send(
            await renderExplorerPage(
                new ExplorerProgram(DefaultNewExplorerSlug, "")
            )
        )
    if (!slug || !existsSync(explorerAdminServer.absoluteFolderPath + filename))
        return res.send(`File not found`)
    const explorer = await explorerAdminServer.getExplorerFromFile(filename)
    return res.send(await renderExplorerPage(explorer))
})

const gitCmsServer = new GitCmsServer({
    baseDir: GIT_CMS_DIR,
    shouldAutoPush: true,
})
gitCmsServer.createDirAndInitIfNeeded()
gitCmsServer.addToRouter(adminRouter)

export { adminRouter }
